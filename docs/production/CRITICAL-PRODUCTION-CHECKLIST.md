# Critical Production Deployment Checklist

## ‚ö†Ô∏è MOST CRITICAL AREAS - Read This First!

These are the areas where mistakes can cause **security breaches, data loss, or system failures**. Pay special attention to these before deploying.

---

## üîê 1. SECURITY & SECRETS (HIGHEST PRIORITY)

### ‚ö†Ô∏è Critical Issues to Avoid

#### A. JWT Secret Security
**Risk**: If your JWT secret is weak or exposed, attackers can forge authentication tokens and access any account.

**What to check:**
```bash
# ‚ùå NEVER use the default secret in production
app.security.jwt.secret=change-me  # DANGEROUS!

# ‚úÖ Generate a strong secret
openssl rand -base64 64
# Example output: K8jN5mP9qR2sT6vX...  (use this!)
```

**Action items:**
- [ ] Generate a cryptographically strong JWT secret (64+ characters)
- [ ] Store it in GitHub Secrets (NOT in code)
- [ ] Never commit secrets to git
- [ ] Rotate secrets periodically (every 90 days)

#### B. Database Password Security
**Risk**: Weak or exposed database password = complete data breach.

**What to check:**
```bash
# ‚ùå NEVER use weak passwords
DATABASE_PASSWORD=password123  # DANGEROUS!
DATABASE_PASSWORD=admin        # DANGEROUS!

# ‚úÖ Use Supabase-generated strong password
# Example: xK9$mP2@vR7#nQ5!tL8...
```

**Action items:**
- [ ] Use the strong password generated by Supabase (save it in password manager!)
- [ ] Store it in GitHub Secrets
- [ ] Never log database passwords
- [ ] Use connection pooling to limit connections

#### C. Exposed Credentials Files
**Risk**: Committed credential files expose your entire GCP project.

**What to check:**
```bash
# Verify these files are NEVER committed
git ls-files | grep -E 'credentials|key\.json|\.env'

# Should return NOTHING. If you see files, REMOVE THEM IMMEDIATELY:
git rm --cached credentials.json
git rm --cached *-key.json
git commit -m "Remove exposed credentials"
git push --force  # ‚ö†Ô∏è Rotate all keys after this!
```

**Action items:**
- [ ] Verify `.gitignore` includes: `credentials.json`, `*-key.json`, `.env`
- [ ] Check GitHub repository for accidentally committed secrets
- [ ] If found, rotate ALL affected credentials immediately
- [ ] Enable GitHub Secret Scanning

#### D. Disable Development Features
**Risk**: Exposed development tools allow attackers to read/modify your database.

**What to check in `application-prod.properties`:**
```properties
# ‚úÖ MUST be disabled in production
spring.h2.console.enabled=false           # ‚úÖ Disabled
springdoc.swagger-ui.enabled=false        # ‚úÖ Disabled (or secure with auth)
spring.jpa.show-sql=false                 # ‚úÖ Disabled (prevents SQL logging)

# ‚ùå NEVER enable these in production
spring.h2.console.enabled=true            # ‚ùå DANGEROUS!
springdoc.swagger-ui.enabled=true         # ‚ùå May expose API structure
spring.jpa.show-sql=true                  # ‚ùå Logs sensitive data
```

**Action items:**
- [ ] H2 console completely disabled
- [ ] Swagger UI disabled or requires authentication
- [ ] SQL logging disabled
- [ ] Debug logging disabled

---

## üîí 2. API SECURITY

### ‚ö†Ô∏è Agent Endpoints Currently PUBLIC

**Current Issue** (in `SecurityConfig.java`):
```java
// ‚ùå TEMPORARY - Currently allows public access
.requestMatchers("/api/agent/**").permitAll()
```

**Risk**: Anyone can use your AI agents without authentication, causing:
- Unauthorized Vertex AI usage (costs you money!)
- Data exposure through conversational queries
- Potential abuse of the system

**Fix Required:**
```java
// ‚úÖ Require authentication for agent endpoints
.requestMatchers("/api/agent/**").authenticated()
```

**Action items:**
- [ ] **CRITICAL**: Remove `.permitAll()` from agent endpoints
- [ ] Require JWT authentication for all `/api/agent/**` endpoints
- [ ] Test that unauthenticated requests are rejected (HTTP 401)
- [ ] Monitor API usage for suspicious activity

### ‚ö†Ô∏è CORS Configuration

**Current Issue** (in `SecurityConfig.java`):
```java
.allowedOrigins(
    "http://localhost:5173",   // ‚ùå Don't need in production
    "http://localhost:8080",   // ‚ùå Don't need in production
    "https://your-production-domain.com"  // ‚ö†Ô∏è MUST UPDATE THIS
)
```

**Risk**: Incorrect CORS allows malicious websites to make requests to your API.

**Action items:**
- [ ] Remove localhost origins from production
- [ ] Add ONLY your production frontend domain(s)
- [ ] Test that unauthorized origins are blocked
- [ ] Use specific domains, avoid wildcards

**Example production config:**
```java
.allowedOrigins(
    "https://inmobiliaria-app.com",
    "https://www.inmobiliaria-app.com"
)
```

---

## üíæ 3. DATABASE CONFIGURATION

### ‚ö†Ô∏è Connection String Update Required

**Current placeholder in `application-prod.properties`:**
```properties
# ‚ö†Ô∏è MUST REPLACE THIS
spring.datasource.url=jdbc:postgresql://postgres.YOUR_PROJECT_REF.supabase.co:5432/postgres
```

**Action items:**
- [ ] Get actual Supabase connection string from project settings
- [ ] Replace `YOUR_PROJECT_REF` with real project reference
- [ ] Test connection before deploying
- [ ] Use connection pooler for production (recommended)

**Get your connection string:**
1. Supabase Dashboard ‚Üí Project Settings ‚Üí Database
2. Copy "URI" from Connection String section
3. Use the Transaction Mode pooler: `[PROJECT-REF].pooler.supabase.com`

### ‚ö†Ô∏è Flyway Migrations

**Risk**: Failed migrations can corrupt your database or cause data loss.

**Critical settings:**
```properties
# ‚úÖ These MUST be set correctly
spring.flyway.enabled=true                # ‚úÖ Enable migrations
spring.flyway.baseline-on-migrate=true    # ‚úÖ Handle existing schema
spring.flyway.clean-disabled=true         # ‚úÖ NEVER allow clean in prod!
```

**Action items:**
- [ ] **NEVER** set `spring.flyway.clean-disabled=false` in production
- [ ] Test all migrations locally first
- [ ] Have database backup before first deployment
- [ ] Monitor first deployment logs carefully
- [ ] Verify all tables created correctly

### ‚ö†Ô∏è Connection Pool Configuration

**Risk**: Too few connections = slow performance. Too many = database overwhelmed.

**Current settings:**
```properties
spring.datasource.hikari.maximum-pool-size=10  # For 1GB RAM Cloud Run
spring.datasource.hikari.minimum-idle=2
```

**Action items:**
- [ ] Start with conservative pool size (10 max)
- [ ] Monitor connection usage in production
- [ ] Adjust based on actual load
- [ ] Watch for connection timeout errors

---

## ‚òÅÔ∏è 4. GOOGLE CLOUD CONFIGURATION

### ‚ö†Ô∏è Service Account Permissions

**Risk**: Too many permissions = security risk. Too few = application doesn't work.

**Required permissions (minimum):**
```bash
# Cloud Run service account needs ONLY:
roles/aiplatform.user              # ‚úÖ Access Vertex AI
roles/secretmanager.secretAccessor  # ‚úÖ Read secrets

# Should NOT have:
roles/owner                         # ‚ùå Too permissive!
roles/editor                        # ‚ùå Too permissive!
roles/iam.serviceAccountUser        # ‚ùå Not needed for Cloud Run SA
```

**Action items:**
- [ ] Grant ONLY required permissions to Cloud Run service account
- [ ] Follow principle of least privilege
- [ ] Do NOT use roles/owner or roles/editor
- [ ] Review IAM policies regularly

### ‚ö†Ô∏è Workload Identity Setup

**Risk**: Incorrect setup = authentication failures for Vertex AI.

**Verify configuration:**
```bash
# Check service account is bound to Cloud Run
gcloud run services describe inmobiliaria-api \
  --region=us-central1 \
  --format="value(spec.template.spec.serviceAccountName)"

# Should show: inmobiliaria-cloudrun@{PROJECT}.iam.gserviceaccount.com
```

**Action items:**
- [ ] Service account created in production project
- [ ] Service account bound to Cloud Run service
- [ ] Vertex AI permissions granted
- [ ] Test agent endpoints after deployment

### ‚ö†Ô∏è Environment Variables

**Risk**: Missing or incorrect environment variables = application crash.

**Critical variables that MUST be set:**
```yaml
# ‚úÖ Required in Cloud Run
SPRING_PROFILES_ACTIVE=prod              # Activates prod config
GOOGLE_CLOUD_PROJECT={your-project-id}   # Must match actual project
GOOGLE_CLOUD_LOCATION=us-central1        # Must match deployment region
GOOGLE_GENAI_USE_VERTEXAI=true          # Enable Vertex AI
DATABASE_URL=jdbc:postgresql://...       # Full Supabase connection string
DATABASE_USERNAME=postgres               # Database user
DATABASE_PASSWORD={from-secret}          # From Secret Manager
JWT_SECRET={from-secret}                 # From Secret Manager
```

**Action items:**
- [ ] Verify ALL environment variables are set in Cloud Run
- [ ] Check GitHub Secrets are configured correctly
- [ ] Ensure project ID matches actual GCP project
- [ ] Test application starts successfully

---

## üåê 5. NETWORK & ACCESS CONTROL

### ‚ö†Ô∏è Cloud Run Access Control

**Current setting:**
```yaml
--allow-unauthenticated  # ‚ö†Ô∏è Public access
```

**Risk**:
- ‚úÖ Needed if frontend directly calls API (most common)
- ‚ö†Ô∏è But you MUST implement JWT authentication at application level

**Action items:**
- [ ] If frontend calls API directly: keep `--allow-unauthenticated` BUT enforce JWT in app
- [ ] If backend-only: remove `--allow-unauthenticated` and set up Cloud IAM
- [ ] Implement rate limiting to prevent abuse
- [ ] Monitor for unusual traffic patterns

### ‚ö†Ô∏è Rate Limiting & DDoS Protection

**Risk**: No rate limiting = API abuse, high costs, service degradation.

**Current state**: ‚ö†Ô∏è No rate limiting implemented

**Recommended solutions:**
1. **Google Cloud Armor** (if using Load Balancer)
2. **API Gateway** (adds rate limiting layer)
3. **Application-level rate limiting** (Spring Boot libraries)

**Action items:**
- [ ] Implement rate limiting (recommended: 100 requests/minute per IP)
- [ ] Configure Cloud Run max instances (prevents runaway costs)
- [ ] Set up budget alerts in GCP
- [ ] Monitor for abuse patterns

---

## üí∞ 6. COST MANAGEMENT

### ‚ö†Ô∏è Vertex AI Costs

**Risk**: Gemini API calls cost money. Abuse or bugs can be expensive.

**Current configuration:**
- Model: `gemini-2.0-flash` (cost-effective choice ‚úÖ)
- No usage limits configured ‚ö†Ô∏è

**Action items:**
- [ ] Set up billing alerts (e.g., alert if >$50/month)
- [ ] Monitor Vertex AI usage in GCP Console
- [ ] Implement request logging to track usage
- [ ] Consider adding usage quotas per user/session
- [ ] Review bills weekly initially

**Vertex AI Pricing (approximate):**
- Gemini 2.0 Flash: ~$0.075 per 1M input tokens
- Monitor your usage: Cloud Console ‚Üí Vertex AI ‚Üí Usage

### ‚ö†Ô∏è Cloud Run Costs

**Risk**: Incorrect configuration leads to unnecessary costs.

**Current settings:**
```yaml
--memory=1Gi          # $0.000010 per GB-second
--cpu=1               # $0.000030 per vCPU-second
--min-instances=1     # ‚ö†Ô∏è Always running = continuous cost
--max-instances=10    # Safety limit ‚úÖ
```

**Action items:**
- [ ] Start with `--min-instances=1` for reliability
- [ ] Monitor actual usage after 1 week
- [ ] Consider `--min-instances=0` if low traffic (cold starts OK)
- [ ] Set reasonable `--max-instances` to cap costs
- [ ] Review Cloud Run billing after first month

**Cost optimization:**
```bash
# If low traffic, allow scale to zero:
--min-instances=0  # Saves money, but cold starts (~10s)

# If high traffic, keep warm:
--min-instances=1  # Costs ~$10/month, no cold starts
```

---

## üìä 7. MONITORING & OBSERVABILITY

### ‚ö†Ô∏è Production Monitoring Setup

**Risk**: No monitoring = you don't know when things break.

**Critical metrics to monitor:**
1. **Application health** - `/actuator/health` endpoint
2. **Error rate** - HTTP 500 responses
3. **Response time** - p95, p99 latency
4. **Database connections** - Connection pool exhaustion
5. **Vertex AI errors** - Authentication failures
6. **Memory usage** - OOM crashes

**Action items:**
- [ ] Set up uptime monitoring (check health endpoint every 1 minute)
- [ ] Configure alerts for:
  - Error rate > 5%
  - P95 latency > 2 seconds
  - Application down for > 1 minute
- [ ] Enable Cloud Logging (automatic with Cloud Run)
- [ ] Review logs daily for first week

### ‚ö†Ô∏è Log Security

**Risk**: Logs can expose sensitive data.

**Check your code doesn't log:**
- ‚ùå Passwords or credentials
- ‚ùå JWT tokens
- ‚ùå Full database connection strings
- ‚ùå Personal identifiable information (PII)

**Action items:**
- [ ] Review all log statements for sensitive data
- [ ] Use parameterized logging (prevents injection)
- [ ] Set production log level to INFO (not DEBUG)
- [ ] Implement log sanitization if needed

---

## üîÑ 8. DEPLOYMENT PROCESS

### ‚ö†Ô∏è Zero-Downtime Deployment

**Risk**: Deployment takes down the system for users.

**Cloud Run provides zero-downtime by default** ‚úÖ But:
- New revision starts before old one stops
- Traffic gradually shifts to new revision
- Failed health checks prevent deployment

**Action items:**
- [ ] Keep health check endpoint reliable
- [ ] Test new revision locally before deploying
- [ ] Monitor deployment in Cloud Run console
- [ ] Have rollback plan ready
- [ ] Keep old revision for quick rollback

### ‚ö†Ô∏è Database Migration Strategy

**Risk**: Failed migrations during deployment = data corruption.

**Deployment order:**
```
1. Backup database (Supabase auto-backups, but verify!)
2. Deploy new code (Flyway runs automatically)
3. Verify migrations succeeded (check logs)
4. Test application endpoints
5. Monitor for errors
```

**Action items:**
- [ ] **ALWAYS** have database backup before deployment
- [ ] Test migrations locally on copy of production data
- [ ] Monitor Flyway logs during first deployment
- [ ] Have rollback SQL scripts ready (just in case)
- [ ] Never make breaking schema changes without backward compatibility

### ‚ö†Ô∏è First Deployment Checklist

**The first deployment is the most critical. Go slowly.**

```bash
# Before deploying:
- [ ] All secrets configured in GitHub
- [ ] Service accounts created and permissions granted
- [ ] Database connection tested
- [ ] Docker image builds successfully locally
- [ ] All tests pass

# During deployment:
- [ ] Watch GitHub Actions logs
- [ ] Watch Cloud Run deployment logs
- [ ] Watch Flyway migration logs
- [ ] Check for errors in Cloud Logging

# After deployment:
- [ ] Test health endpoint
- [ ] Test authentication (login/register)
- [ ] Test agent endpoints
- [ ] Verify database tables created
- [ ] Check all environment variables are set
- [ ] Test from production frontend URL
```

---

## üö® 9. BACKUP & DISASTER RECOVERY

### ‚ö†Ô∏è Database Backups

**Risk**: Data loss without backups.

**Supabase provides automatic backups** ‚úÖ But verify:

**Action items:**
- [ ] Verify Supabase backups are enabled
- [ ] Understand backup retention (7 days free tier)
- [ ] Test database restore process
- [ ] Consider upgrading to Point-in-Time Recovery (paid)
- [ ] Export critical data manually weekly (initial period)

### ‚ö†Ô∏è Disaster Recovery Plan

**Have a plan for:**
1. **Cloud Run service down** ‚Üí Redeploy previous revision
2. **Database corrupted** ‚Üí Restore from Supabase backup
3. **Credentials compromised** ‚Üí Rotate all secrets immediately
4. **Vertex AI quota exceeded** ‚Üí Temporary degraded mode
5. **Complete GCP outage** ‚Üí Status page, communicate with users

**Action items:**
- [ ] Document rollback procedure
- [ ] Test rollback to previous Cloud Run revision
- [ ] Keep copy of working deployment configuration
- [ ] Have backup communication channel (status page)

---

## ‚úÖ PRE-DEPLOYMENT FINAL CHECKLIST

### Security (CRITICAL - Review Twice!)
- [ ] JWT secret is strong (64+ characters) and in GitHub Secrets
- [ ] Database password is strong and in GitHub Secrets
- [ ] No credentials committed to git
- [ ] H2 console disabled in production config
- [ ] Swagger UI disabled or secured
- [ ] Agent endpoints require authentication
- [ ] CORS configured with production domain only
- [ ] SQL logging disabled

### Configuration (CRITICAL)
- [ ] Supabase connection string updated (not placeholder)
- [ ] GitHub Secret `GCP_PROJECT_ID` matches actual project
- [ ] All environment variables configured in workflow
- [ ] Service account created with correct permissions
- [ ] Vertex AI API enabled in production project
- [ ] `application-prod.properties` reviewed and correct

### Testing (CRITICAL)
- [ ] Docker image builds successfully
- [ ] All tests pass locally
- [ ] Application starts with production config locally
- [ ] Database migrations tested locally

### Monitoring (CRITICAL)
- [ ] Billing alerts configured
- [ ] Uptime monitoring configured
- [ ] Error alerts configured
- [ ] First week: daily log reviews scheduled

### Backup (CRITICAL)
- [ ] Supabase backups verified
- [ ] Rollback procedure documented
- [ ] Database restore tested

---

## üÜò IF SOMETHING GOES WRONG

### Immediate Actions

**Application won't start:**
```bash
# Check Cloud Run logs
gcloud run services logs read inmobiliaria-api --region=us-central1 --limit=100

# Check for common issues:
# - Missing environment variables
# - Database connection failure
# - Flyway migration errors
```

**Database connection fails:**
```bash
# Verify connection string
gcloud run services describe inmobiliaria-api \
  --region=us-central1 \
  --format="yaml(spec.template.spec.containers[0].env)"

# Test connection from local machine
psql "postgresql://postgres:[PASSWORD]@[PROJECT-REF].supabase.co:5432/postgres"
```

**Vertex AI authentication fails:**
```bash
# Check service account permissions
gcloud projects get-iam-policy $GCP_PROJECT_ID \
  --flatten="bindings[].members" \
  --filter="bindings.members:serviceAccount:inmobiliaria-cloudrun*"
```

**Rollback to previous version:**
```bash
# List revisions
gcloud run revisions list --service=inmobiliaria-api --region=us-central1

# Rollback to previous revision
gcloud run services update-traffic inmobiliaria-api \
  --region=us-central1 \
  --to-revisions=inmobiliaria-api-00001-abc=100
```

---

## üìû Support Resources

- **Cloud Run Documentation**: https://cloud.google.com/run/docs
- **Supabase Status**: https://status.supabase.com
- **Vertex AI Status**: https://status.cloud.google.com
- **Project Documentation**: `docs/production/DEPLOYMENT-PRODUCTION.md`
- **Configuration Guide**: `docs/production/CONFIGURATION-COMPARISON.md`

---

## ‚ö° Summary: Top 5 Most Critical Items

1. **üîê Security**: Strong JWT secret, no exposed credentials, agent endpoints secured
2. **üíæ Database**: Correct connection string, backups verified, migrations tested
3. **‚òÅÔ∏è GCP Setup**: Service account permissions correct, Workload Identity working
4. **üí∞ Costs**: Billing alerts set, usage monitored, reasonable limits
5. **üìä Monitoring**: Health checks working, error alerts configured, logs reviewed daily

---

**Good luck with your deployment! Go slowly on the first deploy and verify each step.** üöÄ
